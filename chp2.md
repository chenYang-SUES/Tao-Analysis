# 第2章 从头开始：自然数

在本书中，我们将回顾曾在高中以及初等微积分课程上学过的那些知识，但是我们会按照尽可能严格的要求来进行。为此，我们将不得不从最基础的内容开始学习。事实上，我们要追溯到**数**的概念以及数有哪些性质。不可否认，你已经与数字打交道十余年了，并且了解如何利用袋鼠法则化简含有数字的表达式。但是，现在我们将转向一个更加基础的问题，那就是：**为什么**代数法则总是起作用？例如，对于任意三个数 $a$、$b$、$c$，为什么 $a(b+c)$ 等于 $ab+ac$ 总是成立？这种运算法则并不是随意给出的，它能够从数系更为原始也更为基本的性质中推导出来。这将教会你一种新的技能——利用较为简单的性质证明复杂的性质。你会发现，虽然某个命题可能是“显然的”，但是要证明它却好像并不是那么容易。本书中将给出大量这样的练习，另外在这个过程当中，你会被引导着思考*为什么*一个显然成立的命题的确是显然的。这里你将掌握一个技能是使用数学归纳法。**数学归纳法**是很多数学领域中都会用到的一种基本的证明工具。

因此，在这本书的前几章中，我们将让你重新认识一下实分析中用到的各种数系。随着复杂程度的不断提高，这些数系分别是**自然数系 $\mathbf{N}$、整数系 $\mathbf{Z}$、有理数系 $\mathbf{Q}$**以及**实数系 $\mathbf{R}$**。（还存在其他的数系，如**复数系 $\mathbf{C}$**，但在 15.6 节之前，对它们不作研究。）自然数系 $\{0,1,2,\cdots\}$ 是所有数系中最原始的一个，但是自然数并用来构造整数，然后整数又被用来构造有理数。更进一步，有理数被用来构造实数，而实数被用来构造附属。于是，要想从最初的内容开始，我们必须考察自然数。我们将考虑如下问题：人们如何真正地**定义**自然数？（这与如何**使用**自然数是完全不同的两个问题，显然，使用自然数是你非常擅长的事情。这就好比知道如何使用一台计算机与知道如何组装一台计算机是完全不同的两码事。）

对于这个问题的回答要比看起来难得多。根本的问题在于，你使用自然数已经很久了，以至于自然数在你的数学思维中根深蒂固，你会无意识地对自然数做出各种隐含的假设（例如，$a+b$ 总是等于 $b+a$）。另外，像第一次见到自然数系那样去考察它是非常困难的。因此，下面我们将让你完成一个难度相当大的任务：尝试把你所了解的所有关于自然数的知识暂时放在一边，同时忘记如何计数、求和、求乘积以及如何使用代数法则等。我们将尝试逐个引入这些概念并在学习过程中明确地标识出我们的假设都有哪些。此外，在真正地证明出那些更加“高级”的技巧（比如代数法则）之前，我们都不能使用这些技巧。这看起来可能是一个令人烦恼的限制，特别是当我们需要花费大量时间去证明那些“显然”的命题时，但这种把已知事实暂时放在一边的做法对于避免**循环论证**（例如，用高等的知识去证明较初等的理论，然后又用该初等理论去证明之前的高等知识）是非常必要的。同时，这种训练也是夯实数学基础知识的一种非常好的方式。更进一步来说，当我们的课程进展到更加高深的概念，如实数、函数、序列和级数、微分以及积分等时，这里对证明和抽象思维能力的训练将对你有很大的帮助。总之，此处所阐述的结果看起来好像是无关紧要的，但是目前对于我们来说，过程b比结果更重要。（一旦构造出合适的数系，我们就可以重新使用代数法则等，而不需要在每次使用它们之前都进行重新推导。）

我们也要忘掉所了解的十进制。虽然十进制是我们处理数时所采用的一种极为便捷的方法，但对于什么是数这个问题而言，十进制并不是最基本的内容。（例如，人们可以使用八进制或者二进制、甚至罗马数字系统来代替十进制，而且这些进制所得到的数的集合是完全相同的。）另外，尝试去彻底解释什么是十进制并非你想象中那么自然。为什么 $00423$ 与 $423$ 表示的是同一个数，而 $32400$ 与 $324$所表示的却不是同一个数？为什么 $123.4444\cdots$ 是一个实数，但 $\cdots444.321$ 却不是实数？当数相加或者相乘的时候，我们为什么要进位？为什么说 $0.999\cdots$ 与 $1$ 表示的是同一个数？最小正实数是多少？它是不是 $0.00\cdots001$？因此，为了暂不涉及这些问题，我们不会给出关于十进制相关知识的任何假设。然而，对数的描述我们将继续沿用数系的数字符号，如 $1,2,3$ 等，而不去使用其他诸如 $\rm{I,II,III}$ 或者 $0++,(0++)++,((0++)++)++$ （参见下文）等没必要的人工记号。为了保证完整性，在附录 B 中我们会对十进制进行回顾。

## 2.1 皮亚诺公理

现在我们根据**皮亚诺公理**给出定义自然数的一种标准方法，其中皮亚诺公里是由朱塞佩·皮亚诺（1858—1932）首次提出的。但这并非定义自然数的唯一方法。比如另一种方法是通过讨论有限集合的势给出的。比方说，给定一个含有五个元素的集合，我们可以定义 $5$ 来表示这个集合中含有的元素个数。在 3.6 节中，我们将对这种定义自然数的方法进行讨论。但现在我们继续讨论根据皮亚诺公理定义自然数的方法。

如何定义什么是自然数呢？我们可以通俗地说，

> **定义 2.1.1** （非正式的）**自然数**是集合
> $$\mathbf{N}:=\left \{0,1,2,3,4,\cdots  \right \} $$
> 的元素。其中，集合 $\mathbf{N}$ 是由从 $0$ 开始，无休止地往前进行计数所得到的所有元素构成的集合。我们称 $\mathbf{N}$ 为 **自然数集**。
>

**注 2.1.2** 在有些教材中，自然数被定义为从 $1$ 开始，而非从 $0$ 开始，但这仅仅是一种符号约定而已。在这本书中，我们定义集合 $\left \{1,2,3,\cdots \right \}$ 为**正整数集**并记作 $\mathbf{Z}^+$，而不是自然数集。自然数有时也被称为**完整数**（whole number）。

从某种意义上来说，上述定义给出了什么是自然数这个问题的答案：自然数是集合[^1] $\mathbf{N}$ 中的元素。然而这个定义并非真的那么令人满意，因为它带来了一个新的问题：$\mathbf{N}$是什么？“从 $0$ 开始，无休止地进行计数”看起来好像是对 $\mathbf{N}$ 的一个足够直观的定义，但是这种叙述带来很多尚未回答的问题，因此它并不能被人们完全接受。例如：如何确定我们能够无休止地进行计数而不会出现循环回到 $0$ 的情况？你应该如何进行诸如加法、乘法以及指数运算这样的运算？

首先，我们可以回答第二个问题：我们能够利用较为简单的运算来定义复杂的运算。指数运算只不过是重复地进行乘法运算：$5^3$ 就是把 $3$ 个 $5$ 乘在一起。乘法运算只不过是重复地进行加法运算：$5 \times 3$ 就是把 $3$ 个 $5$ 加在一起。（由于减法和除法运算不是完全适用于自然数的运算，因此这里不对它们做论述；只有当我们学到整数和有理数的时候，才会分别对减法和除法进行讨论。）那么加法有时如何定义的呢？它不过是重复地**往前进行计数**或**不断增长**的运算。如果你把 $5$ 加上 $3$，那么你所做的就是让 $5$ 增长了三次。另外，增长看起来是一个基本运算，它无法简化为更加简单的运算；事实上，增长是人们在学习数时首先接触到的运算，它甚至出现在学习加法运算之前。

于是，为了定义自然数，我们将使用如下两个基本概念：数 $0$ 和增量运算。为了与现代计算机语言相一致，我们用 $n++$ 来表示 $n$ 的增量或紧跟在 $n$ 之后的数，例如，$3++=4$，$(3++)++=5$等。这与 $n++$ 在计算机语言中的用法稍有不同。例如，在 C 语言中 $n++$ 实际是把 $n$ 重新赋值为紧跟在 $n$ 之后的那个数。但是在数学中，我们在任何情况下对一个变量仅定义一次，这是因为如果对一个变量定义多次经常会发生混淆的状况；很多命题可能对某变量原有的赋值为真，但是对于该变量新的赋值而言就会变成假的，反之亦然。

因此，这看起来貌似我们要说 $\mathbf{N}$ 是由 $0$ 以及所有能通过增量运算由 $0$ 得到的数构成的：$\mathbf{N}$ 应该由如下这些对象构成：
$$0, \ 0++, \ (0++)++, \ ((0++)++)++, \ \cdots$$
如果我们把自然数用上述对象来表述，那么将得到如下关于 $0$ 和增量运算 $++$ 的公理。

> **公理 2.1** $0$ 是一个自然数。

> **公理 2.2** 如果 $n$ 是一个自然数，那么 $n++$ 也是一个自然数。

于是，举例来说，我们利用一次公理 2.1 和两次公理 2.2，能够推得 $(0++)++$ 是一个自然数。显然这个记号将变得越来越不灵便，因此我们共同约定采用更熟悉的记号来表示这些数。

> **定义 2.1.3**  我们定义 $1$ 为数 $0++$，$2$为数 $(0++)++$，$3$ 为数 $((0++)++)++$，等等。（换而言之，$1:=0++$，$2:=1++$，$3:=2++$，等等。在本书中，我用“$x:=y$”来表示命题“令 $x$ 的值等于 $y$”。）

于是，举例来说，我们有：

> **命题 2.1.4** 3是一个自然数。

**证明：** 根据公理2.1可知，$0$是一个自然数。根据公理 2.2，$0++=1$ 是一个自然数。再次利用公理 2.2 就可以得到，$2++=3$是一个自然数。<span style="float: right">□</span>

目前看来我们似乎已经对自然数进行了充分的描述，但是还没有彻底弄清楚 $N$ 的特性。

**例 2.1.5** 考察一个由数$0、1、2、3$所构成的数系。在这个数系中，增量运算将从 $3$ 绕回到 $0$。用更加准确的语言来描述就是，$0++$ 等于 $1$，$1++$ 等于 $2$，$2++$ 等于 $3$，但是 $3++$ 等于 $0$（通过给出 $4$ 的定义，可以得到到 $3++$ 也等于 $4$）。当人们尝试在计算机中存储一个自然数的时候，这种“绕回”的状况在现实生活中也会发生：如果我们从 $0$ 开始反复运行增量运算，最终计算机内存将溢出并且数将归为 $0$（尽管导致这种状况发生所需运行的增量运算的次数可能会非常庞大，比如只有在运行 $65 \ 536$）次增量运算后，一个整数的双字节表示才会绕回到 $0$）。我们注意到这种类型的数系遵守公理 2.1 和公理 2.2 ，尽管这显然与我们凭直觉所感知的自然数应该具备的特性并不一致。

为了防止出现这种“绕回状况”，我们将引入另一个公理。

> **公理 2.3** $0$ 不紧跟在任何自然数之后。换而言之，对任意一个自然数 $n$，$n++ \neq 0$ 均成立。

现在我们可以证明某些绕回状况不会发生，比如利用下述命题，我们可以阻止例 2.1.5 中绕回状况的发生。

> **命题 2.1.6**  $4$ 不等于 $0$。

不要笑！因为我们是按照这样的方式来定义 $4$ 的——$4$是把 $0$ 增长、增长、增长、在增长之后得到的，所以数字 $4$ 和 $0$ 不是同一个数这个**先验命题**（a priori）并不一定为真，尽管该命题为真是“显然的”。（a priori 是 beforehand 的拉丁语，指人们在开始进行证明或论述之前，就已经知道或假定其为真的命题。它的反义词是 a posteriori，表示人们通过证明或论述后，才能确定其为真的命题。）在例 2.1.5 中的情况，$4$ 实际上是等于 $0$ 的，并且在自然数的标准双字节计算机表示中，以 $65 \ 536$ 为例，它是等于 $0$ 的（根据我们对 $65 \ 536$ 的定义，$65 \ 536$  表示把 $0$ 运行  $65 \ 536$ 次增量运算之后得到的结果）。

**证明：** 由定义知，$4=3++$。根据公理 2.1 和公理 2.2 可知 $3$ 是一个自然数，因此根据公理 2.3 可得，$3++ \neq 0$，即$4 \neq 0$。<span style="float: right">□</span>

然而，即便现在有了新的公理，我们的数系仍然可能表现出其他病态特性。

例 2.1.7 考虑由 $0、1、2、3、4$ 这五个数构成的数系。在这个数系中，增量运算在数 $4$ 处碰到了“天花板”。更准确地说，令 $0++=1$，$1++=2$，$2++=3$，$3++=4$，但令 $4++=4$（换言之，有 $5=4$，从而 $6=4$，$7=4$，等等）。这与公理 2.1、公理 2.2 以及公理 2.3 并不矛盾。有类似问题的另一个数系是这样的：它的增量运算同样存在绕回状况，但并不是绕回到 $0$，例如，令 $4++=1$（那么可以得到 $5=1$，进而得到 $6=2$，等等）。

有许多方法可以阻止上述情况的发生，但是最简单的方法之一是假定下面这个公理成立。

> **公理 2.4**  对于不同的自然数而言，紧跟在它们之后的数字也一定是不同的。也就是说，如果 $n$ 和 $m$ 都是自然数，并且 $n \neq m$，那么 $n++ \neq m++$。等价说法为[^2]，如果 $n++ = m++$，那么一定有 $n=m$。

举例来说，我们得到：

> **命题 2.1.8**  $6$ 不等于 $2$。

**证明：** 为了推出矛盾，不妨假设 $6=2$ 成立。那么有 $5++ = 1++$，故根据公理 2.4可得，$5=1$，进而有$4++=0++$。再次利用公理 2.4，我们有$4=0$，这显然与之前命题 2.1.6 相矛盾。<span style="float: right">□</span>

正如我们从该命题中看到的那样，看起来好像所有的自然数都是两两不相等的。但是现在仍然存在这样一个问题：虽然根据公理（特别是公理 2.1 和 公理 2.2）我们能够确信 $0,1,2,3,\cdots$是 $\mathbf{N}$ 中的不同元素，但是仍旧存在一个问题，那就是可能还有另外的不是上述形式的“流氓”元素存在于我们的数系当中。

**例 2.1.9** （非正式的）假设我们数系 $\mathbf{N}$ 是由如下所示的整数和半整数共同构成的：
$$N:=\left \{ 0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, \cdots \right \}$$
（这个例子之所以被标注为“非正式的”是因为我们在这里使用了实数，但是目前我们不应该使用实数。）我们能够验证该集合仍旧满足公理 2.1~公理 2.4。

我们希望得到这样一个公理，它告诉我们 $\mathbf{N}$ 中所有的元素都可以通过对 $0$ 进行增量运算得到，从而能够从 $\mathbf{N}$ 中排除像 $0.5$ 这样的元素。但是若不利用我们正尝试去定义的自然数，想要把我们所说的“通过······得到”这句话量化地解释清楚是困难的。幸运的是，存在一种巧妙的方案试着去处理此事。

> **公理 2.5**（数学归纳法原理） 令 $P(n)$ 表示自然数 $n$ 的任意一个性质，如果 $P(0)$ 为真且 $P(n)$ 为真时一定有 $P(n++)$ 也为真，那么对于任意自然数 $n$，$P(n)$ 一定为真。

**注 2.1.10**   此处的“性质”到底指的是什么，我们还不太清楚。但是 $P(n)$ 有如下一些例子：“$n$ 是偶数”“$n$ 等于 $3$”“$n$ 是方程$(n+1)^2=n^2+2n+1 的解$”，等等。当然我们还没有定义其中的许多概念。但是当我们给出定义后，公理 2.5 将能够应用到这些性质中。[一个逻辑上的备注：由于这个公理不仅涉及**变量**，同时也涉及**性质**，所以它在本质上与其他四个公理是不同的。事实上，公理 2.5 严格来说应该被称为**公理模式**而非**公理**——它是一个模板而不是一个独立的公理，在这个模板上可以构造出很多个（无穷多个）公理。进一步讨论其中的区别将远远超出本书的范围，而且这种讨论会涉及逻辑学的相关内容。]

隐藏在这个公理背后的通俗的直观说明如下。假设 $P(n)$ 满足如下条件：$P(0)$ 为真，且 $P(n)$ 为真时，$P(n++)$ 一定为真。那么由于 $P(0)$ 为真，所以 $P(0++)=P(1)$ 为真。又因为 $P(1)$ 为真，所以 $P(1++)=P(2)$ 也为真。通过不断重复这个过程，我们可以得到 $P(0),P(1),P(2),P(3),\cdots$全为真。然而根据上述推导过程，以 $P(0.5)$ 为例，我们永远得不出$P(0.5)$为真。因此，对于包含如 $0.5$ 这样“非必要”元素的数系，公理 2.5 将失效。（实际上，我们能够给出关于这个事实的“证明”。把公理 2.5 应用到具有如下性质的 $P(n)$ 中：“$n$ 不是一个半整数”，即 $n$ 不是一个整数加上 $0.5$。于是可以推出 $P(0)$ 为真，且当 $P(n)$ 为真时 $P(n++)$ 一定为真。那么公理 2.5 说明了对任意自然数 $n$，$P(n)$ 均为真。换言之，所有自然数都不是半整数。特别的$0.5$不可能是自然数。由于我们尚未定义诸如“整数”“半整数”以及“$0.5$”这类概念，因此这个“证明”并非真正意义上的证明。但是关于归纳法原理是如何将所有不是“真”自然数的数排除在 $\mathbf{N}$ 之外的，该证明应该给了你一些启示。）

归纳法原理为我们提供了一种证明某性质 $P(n)$ 对任意自然数 $n$ 均为真的方法。因此在本书剩余部分中，我们将看到许多具有如下形式的证明过程。

> **命题 2.1.11** 对任意的自然数 $n$，某性质 $P(n)$ 恒为真。

**证明：** 我们利用归纳法来证明。首先证明最基本的 $n=0$ 时的情况，结论成立，也就是证明 $P(0)$ 为真。（此处插入关于 P(0) 为真的证明。）现在归纳性地假设 $n$ 是一个自然数，同时 $P(n)$ 已经证明为真。接下来我们证明 $P(n++)$ 也为真。（在已知 $p(n)$ 为真的前提下，插入关于 $P(n++)$ 为真的证明。）到这里整个归纳过程就结束了，因而对所有的自然数 $n$，$P(n)$ 恒为真。<span style="float: right">□</span>

当然，我们没有必要严格地按照上述证明过程中所采用的模板、措辞以及语句顺序来展开证明，但是利用归纳法做出的证明一般都与上面这种形式相同。后面我们还将遇到一些其他的归纳法变体，例如，逆向归纳法（参见习题 2.2.6）、强归纳法（参见习题 2.2.14）和超限归纳法（参见引理 8.5.15）。

公理 2.1~公理 2.5被称为关于自然数的**皮亚诺公理**。这几个公理看起来非常可信，于是我们给出下面这个假设。

> **假设 2.6**（非正式的）存在一个数系 $\mathbf{N}$，我们称 $\mathbf{N}$ 中的元素为自然数，而且公理 2.1~公理 2.5 对 $\mathbf{N}$ 均成立。

在下一章中，一旦规定了在集合与函数中所使用的记号，我们将进一步对这个假设作出更精确的描述。

**注 2.1.12** 我们把这个数系 $N$ 称为自然数系。当然，我们会考虑到这样一种可能的情况：存在多个自然数系，比如，印度—阿拉伯数系$\left \{1,2,3,\cdots\right \}$和罗马数系$\left \{\rm{O,I, II, III, IV, V, VI, \cdots} \right \}$，而且不嫌麻烦的话，我们可以把它们看作不同的数系。但是，这些数系显然是完全等价的（用专业语言来描述是**同构**的），这是因为我们可以构造出一一对应关系：$0 \leftrightarrow \rm{O}$，$1\leftrightarrow \rm{I}$，$2\leftrightarrow \rm{II}$，等等，这个映射把印度—阿拉伯数系中的零对应到罗马数系中的零，并且还保持了增量运算（例如，如果把 $2$ 对应到 $\rm{II}$，那么 $2++$ 将对应到 $\rm{II}++$）。对这种类型的等价关系更加精确的表述，参见习题 3.5.13。因为自然数系的所有变形都是等价的，所以认为存在不同的自然数系是毫无意义的，并且我们只使用单独一个自然数系去做数学研究。

对于假设 2.6，我们将不做证明（尽管最终我们会把它包含在有关集合论的公理中，参见公理 3.7），并且它是我们做出的唯一一个关于数系的假设。现代分析论中非常引人注目的一个成就是，只从上述五个非常基本的公理和集合论中的某些附加公理出发，就能构造出其他所有的数系、生成函数，并进行我们通常所做的全部代数和微积分研究。

**注 2.1.13**（非正式的）自然数系有一个非常有趣的特点：尽管每一个自然数都是有穷的，但是由自然数所构成的集合却是无穷大的；也就是说，虽然 $\mathbf{N}$ 是无穷大的，但是 $\mathbf{N}$ 是由各个有穷的元素构成的（整体大于它的任意部分）。不存在无穷大的自然数；倘若比较熟悉有穷和无穷的概念，那么我们可以利用公理 2.5 来证明这种说法。（显然 $0$ 是有穷的。另外，如果 $n$ 是有穷的，那么 $n++$ 自然也是有穷的。因此，根据公理 2.5 可知，所有自然数都是有穷的。）这样看来，自然数系能够**趋向于**无穷大，但是它不可能真的取到无穷大；无穷大不是自然数。（存在其他的数系，使得“无穷大”是该数系的元素，例如：基数系、序数系以及 $p$ 进数系，然而它们并不遵循归纳法原理，而且完全不在本书的讨论范围之内。）

**注 2.1.14** 注意，我们对自然数的定义是**公理化**的而非**构造性**的。我们还没有告诉你什么是自然数（为此，我们不提出下面这样的问题：数是由什么组成的，它们是物理对象吗，它们度量的对象是什么，等等）。我们只列出一些你利用自然数可以做的事情（事实上，目前我们已经定义过的自然数上的运算只有增量运算）以及自然数所具备的一些性质。数学研究就是这样进行的：将研究对象进行**抽象**处理，只关心研究对象具备什么样的性质，并不在乎研究对象是什么或者它们意味着什么。如果人们想做数学研究，那么一个自然数是否表示算盘珠子的某种排列，或者计算机内存中字节的某种编排，又或者某些不具备物理形态的更加抽象的概念，这都无关紧要。只要你能让它们增长，能够判断它们中的任意两个是否相等，并且对它们可以做相加和相乘这样的算数运算，那么从数学研究的目标来说，它们就是真正的数（当然，前提是它们能够满足那些必要的公理。）从其他的数学对象出发来构造自然数也是有可能的。例如，从集合出发来构造自然数，然而有多种方法构造一个自然数系的有效模型可以，而争论到底哪个模型是“真”的，至少对一个数学家来说是毫无意义的。只要它满足所有的公理，并能够正确的运作，那么对于数学研究来说，它就是足够好的模型。

**注 2.1.15** 从历史的角度来说，实现对数的公理化处理事近代才发生的事情，距今只有一百多年。在那之前，数一般被认为不可避免地与某些外部概念密切关联，例如：计算集合的势、测量线段的长度或者计算物体的质量等。在人们的认知不得不从一个数系转向另一个数系之前，上面这种对数的理解是合理且有效的。比如，通过数珠子的方式去理解数，对数的概念化是很有好处的（例如通过数珠子很容易就形成 $3$ 和 $5$ 的概念），但是对于 $-3、\frac {1} {3}、\sqrt{2}$ 或 $3+4i$ 这样的数来说，数珠子的方法就不怎么起作用了。因此，数论中每一次伟大的进步——负数、无理数、复数甚至是数字0——都会带来大量不必要的哲理烦恼。数可以通过公理来抽象地理解而不需要借助任何实物模型，这是 19 世纪后期的一个伟大发现。当然，在方便的情况下，数学家可以使用实物模型来帮助自己更好地展现直观认识并加深理解，但是当这些模型对研究造成阻碍的时候，它们也会被轻易地抛弃。

根据前面这些公理，可以得到这样一个结论：现在我们能够**递归**地定义序列。假设我们希望通过下列方式来构造一个数列 $a_0,a_1,a_2,\cdots$：首先定义 $a_0$ 的基值，例如 $a_0:=c$，其中 $c$ 是某个固定的数。然后令 $a_1$ 为关于 $a_0$ 的某个函数，$a_1:=f_0(a_0)$，令 $a_2$ 是关于 $a_1$ 的某个函数，$a_2=f_1(a_1)$，以此类推。一般地，我们记作 $a_{n++}:=f_n(a_n)$，其中 $f_n$ 是某个 $\mathbf{N}$ 到 $\mathbf{N}$ 的函数。 利用 前面所有的公理能够推出，对任意给定的自然数 $n$，上述过程将对数列中的元素 $a_n$ 给出一个单一的值。更准确地说[^3]：

> **命题 2.1.16**（递归定义）假设对任意自然数  $n$，都存在某个从自然数系到自然数系的函数 $f_n: \mathbf{N} \rightarrow \mathbf{N}$，令 $c$ 为某个固定的自然数。那么对任意自然数 $n$，都能够确定唯一的自然数 $a_n$，使得 $a_0=c$ 以及 $a_{n++}=f_n(a_n)$ 恒成立。

**证明：**（非正式的）利用归纳法来证明。首先观察可知，上述过程对 $a_0$ 赋予了单一值，即 $c$。（根据公理 2.3 可知，无论 $a_{n++}:=f_n(a_n)$ 是如何定义的，都不能改变 $a_0$ 的值。）现在归纳性地假设上述过程对 $a_n$ 赋予了单一的值，那么它必定也对 $a_{n++}$ 赋予了单一值，即 $a_{n++}:=f_n(a_n)$。（由公理 2.4 可知， 无论其他 $a_{m++}:=f_m(a_m)$是如何定义的，均不能改变 $a_{n++}$ 的值。）到此归纳过程就结束了，从而对任意的自然数 $n$，$a_n$ 都被定义了，并且每一个 $a_n$ 都被赋予了单一的值。

注意所有的公理在这个过程中是如何被应用的。在一个数系中，如果存在某种类型的绕回状况，那么递归定义就不适用于该数系。这是因为序列中的某些元素将会连续不断地被重新定义。例如，在例 2.1.5 中，因为 $3++=0$，所以 $a_0$（至少）存在两种相矛盾的定义，$c$ 或者 $f_3(a_3)$。在一个含有多余元素（比如 $0.5$ 的数系中，元素 $a_{0.5}$ 将永远不会被定义）。

递归定义是非常强大的。例如，我们能够利用它去定义加法和乘法，现在我们就开始学习这部分的内容。

## 2.2 加法

目前来说，自然数系非常简单，我们所知道的只有一种运算：增量运算，以及少数公理。但是现在我们可以构造出更加复杂的运算，如加法运算。

具体的做法如下：$5$ 加上 $3$ 与对 $5$ 进行 $3$ 次增量运算是一样的，这比 $5$ 加上 $2$ 多进行了一次增量运算；而 $5$ 加上 $2$ 又比 $5$ 加上 $1$ 多进行了一次增量运算； $5$ 加上 $1$ 又比 $5$ 加上 $0$ 多进行一次增量运算，而 $5$ 加上 $0$ 的结果应该恰好是 $5$。于是我们给出加法的如下递归定义。

**定义 2.2.1**（自然数的加法）令 $m$ 为一个自然数，我们定义 $m$ 加上 $0$ 为 $0+m:=m$。现在归纳的假设我们已经定义了如何把 $m$ 加上 $n$，那么我们把 $m$ 加上 $n++$ 定义为 $(n++) + m:=(n+m)++$。

于是 $0+m$ 就是 $m$，$1+m=(0++)+m$ 就是 $m++$，$2+m=(1++)+m=(m++)++$，以此类推。例如，我们有 $2+3=(3++)++=4++=5$。从上一节关于递归的讨论中可以看出，对任意自然数 $n$，我们已经定义了 $n+m$。现在我们把之前一般性的讨论特殊化为 $a_n=n+m$ 和 $f_n(a_n)=a_n++$ 的情形。注意这个定义是不对称的：$3+5$ 表示把 $5$ 增加了 $3$ 次，而 $5+3$ 表示把 $3$ 增加了 $5$ 次。当然，它们生成的值是一样的，都是 $8$。更一般地，事实上对任意的自然数 $a$ 和 $b$，$a+b=b+a$ 均成立（我们将简短地给出证明），尽管这并不能马上从定义中看出。

注意，利用公理 2.1、公理 2.2 以及归纳法（公理 2.5），我们很容易证明两个自然数的和仍旧是自然数。（为什么？）

!!! question 随想
    证明：将 $m$ 设为定值，对 $n$ 采用归纳法。首先证明最基本的 $n=0$ 的情况，结论成立，也就是证明 $0+m$ 为自然数。根据定义 2.2.1，$0+m=m$，成立。现在归纳性地假设 $n$ 是一个自然数，同时 $n+m$ 为自然数。接下来我们证明 $(n++) + m$也是一个自然数，根据定义 2.2.1，$(n++)+m=(n+m)++$。由于 $n+m$为自然数，根据公理 2.2，$(n+m)++$也是自然数。到这里整个归纳过程就结束了，因而对所有的自然数 $n$，$n+m$ 均为自然数。<span style="float: right">□</span>

此刻，我们只知道关于加法的两个事实：$0+m=m$ 和 $(n++)+m=(n+m)++$。值得注意的是，这已经足以用来推导出我们所知道的关于加法的其他任何事情。我们从一些基本的引理[^4]开始。

> **引理 2.2.2** 对任意的自然数 $n$，$n+0=n$恒成立。

注意，不能根据 $0+m=m$ 立即推导出该结论，这是因为目前我们还不知道有 $a+b=b+a$。

**证明：** 采用数学归纳法来证明。因为 $0+m=m$对任意自然数 $m$ 均成立并且 $0$ 是一个自然数，所以我们能够取得最基本的情况 $0+0=0$。现在归纳性地假设 $n+0=n$ 成立。我们希望证明 $(n++)+0=n++$。根据加法的定义，$(n++)+0=(n+0)++$；又根据 $n+0=n$ 可以推导出 $(n+0)++=n++。至此整个归纳过程就结束。<span style="float: right">□</span>

> **引理 2.2.3** 对任意的自然数 $n$ 和 $m$，有 $n+(m++)=(n+m)++$.

同样，因为目前我们还不知道有 $a+b=b+a$，所以不能从 $(n++)+m=(n+m)++$ 中推导出本结论。

**证明：** 将 $m$ 设为定值，对 $n$ 采用归纳法。首先考虑最基本的情况，$n=0$。此时我们必须证明 $0+(m++)=(0+m)++$。根据加法的定义可得，$0+(m++)=m++$ 以及 $0+m=m$。所以，要证明等式的两端均与 $m++$ 相等，进而该等式两端相等。现在归纳性地假定 $n+(m++)=(n+m)++$，那么我们必须证明 $(n++)+(m++)=((n++)+m)++$。根据加法的定义，上式左端等于 $(n+(m++))++$，又由归纳性假设可得 $(n+(m++))++=((n+m)++)++$。类似地，根据加法的定义可得，$(n++)+m=(n+m)++$，从而等式右边也等于 $((n+m)++)++$。因此我们证明了等式左端等于右端，从而整个归纳过程到这里就结束了。<span style="float: right">□</span>

作为引理 2.2.2 与引理 2.2.3 的一个特别推论，我们得到 $n++=n+1$。（为什么？）

!!! question 随想
    证明：根据定义 2.1.3、引理2.2.3 和引理2.2.2可得 $n+1=n+(0++)=(n+0)++=n++$；<span style="float: right">□</span>

如之前承诺的，现在我们证明 $a+b=b+a$。

> **命题 2.2.4**（加法是可交换的）对任意自然数 $n$ 和 $m$，有 $n+m=m+n$ 成立。

**证明：** 将 $m$ 设为定值，对 $n$ 采用归纳法。首先证明当 $n=0$ 时结论成立，也就是证明 $0+m=m+0$。一方面，根据加法的定义可以推出 $0+m=m$；另一方面，根据引理 2.2.2 可得 $m+0=m$。于是 $n=0$ 时结论成立。现在归纳性地假设 $n+m=m+n$成立，那么我们要证明 $(n++)+m=m+(n++)$。根据加法的定义，$(n++)+m=(n+m)++$；根据引理 2.2.3，$m+(n++)=(m+n)++$，但由归纳假设 $n+m=m+n$ 可知 $(m+n)++=(n+m)++$。因此 $(n++)+m=m+(n++)$，进而归纳过程结束。<span style="float: right">□</span>

> **命题 2.2.5**（加法是可结合的）对任意三个自然数$a、b、c$，有 $(a+b)+c=a+(b+c)$

**证明：** 参见习题 2.2.1。<span style="float: right">□</span>

正是因为有了这条结合律，我们可以把$a、b、c$的和写成 $a+b+c$ 的形式，而无需顾虑它们是按照什么样的次序加起来的。

下面，我们给出消去律。

> **命题 2.2.6** （消去律）令 $a、b、c$ 为三个自然数并且满足 $a+b=a+c$，那么 $b=c$ 成立。

注意，由于目前我们还没有给出减法和负数的概念，所以这里不能直接利用减法或者负数对该命题进行证明。事实上，消去律对于后面我们定义减法（和整数）的概念至关重要，因为在正式定义减法之前，消去律就涉及一种“虚拟减法”。

**证明：** 我们通过对 $a$ 进行归纳来证明该命题。首先考虑最基本的情况 $a=0$，我们有 $0+b=0+c$，那么根据加法的定义，由 $0+b=0+c$ 可以得到 $b=c$，故当 $a=0$ 时结论得证。现在归纳性假设关于 $a$ 的消去律成立（进而从 $a+b=a+c$ 中可以得到 $b=c$），接下来我们要证明关于 $a++$ 的消去律也成立。换言之，就是在假设$(a++)+b=(a++)+c$成立时，去证明 $b=c$ 成立。根据加法的定义，我们有 $(a++)+b=(a+b)++$ 和 $(a++)+c=(a+c)++$，从而可以得到 $(a+b)++=(a+c)++$。根据公理 2.4，我们进一步得到 $a+b=a+c$。因为我们已知关于 $a$ 的消去律成立，所以有 $b=c$ 成立，结论得证。至此归纳法结束。<span style="float: right">□</span>

现在我们讨论加法和正性是如何相互作用的。

> **定义 2.2.7** （正自然数）称一个自然数 $n$ 是正的，当且仅当它不等于 $0$。

> **命题 2.2.8** 如果 $a$ 是正的并且 $b$ 是自然数，那么 $a+b$ 是正的（从而根据命题 2.2.4 可知，$b+a$ 也是正的）。

**证明：** 我们通过对 $b$ 进行归纳来证明该命题。如果 $b=0$，那么 $a+b=a+0=a$ 显然是正的，从而 $b=0$ 时的结论得证。现在归纳性地假设 $a+b$ 是正的。那么根据公理 2.3 可知，$a+(b++)=(a+b)++$ 不等于 $0$，从而 $a+(b++)$ 是正的。至此归纳法结束。<span style="float: right">□</span>

> **推论 2.2.9** 如果 $a$ 和 $b$ 是自然数并且满足 $a+b=0$，那么 $a=0$ 且 $b=0$。

**证明：** 假设结论的反面 $a \neq 0$ 或 $b \neq 0$ 成立。如果 $a \neq 0$，那么 $a$ 是正的，从而根据命题 2.2.8 可知，$a+b$是正的，这显然与已知条件 $a+b=0$ 相矛盾。类似地，如果 $b \neq 0$，那么 $b$ 是正的，同样根据命题 2.2.8 可知，$a+b$ 是正的，这与 $a+b=0$ 相矛盾。于是 $a$ 和 $b$ 必须同时为 $0$。<span style="float: right">□</span>

> 引理 2.2.10 令 $a$ 表示一个正自然数，那么恰巧存在一个自然数 $b$ 使得 $b++=a$。

**证明：** 参见习题 2.2.2。<span style="float: right">□</span>

一旦有了加法的概念，我们就可以定义**序**的概念。

**定义 2.2.11**（自然数的序）令 $n$ 和 $m$ 表示任意两个自然数。我们称 $n$ 大于等于 $m$，并且记作 $n \geqslant  m$ 或者 $m \leqslant n$，当且仅当存在自然数 $a$ 使得 $n=m+a$。我们称 $n$ 严格大于 $m$，并且记作 $n > m$ 或者 $m < n$，当且仅当 $n \geqslant m$ 且 $n \ne m$。

于是，例如由于 $8=5+3$ 并且 $8 \ne 5$，所以 $8 > 5$。另外注意，对任意 $n$ 均有 $n++>m$；因此不存在最大的自然数 $n$，这是因为下一个数 $n++$ 总是更大。

> **命题 2.2.12**（自然数的序的基本性质）令 $a、b、c$为任意自然数，那么：
> (a)（序是自反的）$a \geqslant a。$
> (b)（序是可传递的）如果 $a \geqslant b$ 并且 $b \geqslant c，$那么 $a \geqslant c。$
> (c)（序是反对称的）如果 $a \geqslant b$ 并且 $b \geqslant a，$那么 $a = b。$
> (d)（加法保持序不变）$a \geqslant b，$当且仅当 $a + c \geqslant b + c。$
> (e) $a < b，$当且仅当 $a++ \leqslant b。$
> (f) $a < b，$当且仅当存在正自然数 $d$ 使得 $b=a+d。$

**证明：** 参见习题 2.2.3。<span style="float: right">□</span>

> **命题 2.2.13** （自然数序的三歧性）令 $a$ 和 $b$ 表示任意两个自然数，那么在下面三种表述中恰有一种表述为真：$a<b$，$a=b$，$a>b$。

**证明：** 这里只给出一个证明的框架，缺少的部分将在习题 2.2.4 中补充。

首先我们证明 $a < b$、$a =b$、$a > b$ 这三种表述中同时为真的表述个数不超过一个。如果 $a < b$，那么根据定义可知 $a \ne b$；同样，如果 $a > b$，根据定义可知 $a \ne b$。如果 $a>b$ 并且 $a<b$，那么根据命题 2.2.12 可知 $a=b$，这显然与 $a \ne b$ 相矛盾。因此同时为真的表述个数不超过一个。

现在我们证明至少有一个表述为真。保持 $b$ 不变，对 $a$ 进行归纳。当 $a=0$时，对所有的 $b$ 均有 $0 \leq b$，（为什么？）因此我们得到 $0=b$ 或者 $0<b$，从而 $a=0$时的结论得证。现在我们假设命题对于 $a$ 已经被证明成立的，下面我们要证明的是该命题对 $a++$ 也同样成立。从关于 $a$ 的三歧性中可知，存在三种可能的情况：$a<b$、$a=b$ 以及 $a>b$。如果 $a>b$，那么有 $a++>b$。（为什么？）如果 $a=b$，那么 $a++>b$。（为什么？）现在假设 $a<b$，那么根据命题 2.2.12 可知 $a++ \leqslant b$。于是我们得到要么 $a++=b$，要么 $a++ < b$，其中任何一种情况都符合我们的要求。至此归纳法结束。<span style="float: right">□</span>

!!! question 随想
    - “对所有 $b$ 均有 $0 \leqslant b$”
        - 根据加法定义（定义 2.2.1）和加法的可交换性（命题 2.2.4）可得，对任意自然数 $b$，均有 $0+b=b+0=b$，再根据自然数序的定义（定义2.2.11）可得 $0 \leqslant b$。<span style="float: right">□</span>
    - “如果 $a>b$，那么有a++>b”
      - 根据命题 2.2.12，该命题等价于“如果 $a \geqslant b++$，那么 $a++ \geqslant b++$”$a++=a+1$，根据定义 2.2.11 可知 $a++ \geqslant a$，根据序的可传递性（命题 2.2.12）可知，$a++ > b++$，命题得证 <span style="float: right">□</span>
    - “如果$a=b$，那么$a++ > b$”
      - 由于 $a=b$，因此 $a++ = b++$，根据加法的定义$0+(b++)=(b++)+0=b++$，根据自然数序的定义可知 $a++ \geqslant b++$，再根据命题 2.2,.12 可知 $a++ > b$ <span style="float: right">□</span>
序的这些性质让我们得到归纳法原理的一个更强的形式。

> **命题 2.2.14** （强归纳法原理）令 $m_0$ 表示一个自然数，$P(m)$表示与任意自然数 $m$ 有关的性质。假设对于任意满足 $m \geqslant m_0$ 的自然数 $m$，均有如下内容成立：若 $P(m')$ 对任意满足 $m_0 \leqslant m' < m$ 的自然数 $m'$ 均为真，那么 $P(m)$ 也为真。（特别地，这意味着 $P(m_0)$ 为真，因为当 $m = m_0$ 时，前提中的 $m'$ 取值范围为空。于是我们能够断定，对于任意满足 $m \geqslant m_0$）的自然数 $m$，$P(m)$ 为真。

注 2.2.15 在应用强归纳法原理的时候，我们通常令 $m_0 = 0$ 或者 $m_0=1$。

**证明：** 参见习题 2.2.5。

## 习题

2.2.1 证明命题 2.2.5。（提示：固定两个变量，对第三个变量进行归纳。）

**证明：** 将 $a、b$ 设为定值，对 $c$ 采用归纳法。首先考虑最基本的情况 $c=0$，此时我们必须证明 $(a+b)+0=a+(b+0)$。根据引理 2.2.2 可得 $(a+b)+0=a+b$、$a+(b+0)=a+b$，所以，要证明的等式的两端均与 $a+b$ 相等，进而该等式两个端相等。现在归纳性地假定 $(a+b)+c=a+(b+c)$，我们必须证明 $(a+b)+(c++)=a+(b+c(++))$。根据加法的定义及引理2.2.3，等式左端$(a+b)+(c++)=((a+b)+c)++$，又由归纳假设可得$((a+b)+c)++=(a+(b+c))++$。类似地，等式右端 $a+(b+(c++))=a+(b+c)++=(a+(b+c))++$，因此，我们证明了等式左端等于等式右端，从而整个归纳过程到这里就结束了。<span style="float: right">□</span>

2.2.2 证明引理 2.2.10.（提示：利用归纳法。）

**证明：** 对 $a$ 采用归纳法，令 $P(a)$ 表示命题“如果 $a$ 是一个正自然数，那么恰巧存在一个自然数 $b$ 使得 $b++=a$”。$P(0)$ 是空虚的真命题，因为 $0$ 不是一个正自然数（前提为假，则蕴涵关系自动为真，见 p.426 附录 A）。现在归纳性地假定 $P(a)$ 为真，我们必须证明 $P(a++)$ 为真，即恰巧存在一个自然数 $b$ 使得 $b++=a++$。首先证明存在性，令 $b：=a$，则 $b++=a++$ 显然成立；其次证明唯一性，令 $c$ 也是一个满足条件的自然数，即 $c++=a++$。根据公理 2.2.4 可知 $c=a$，而 $a=b $，所以 $a=b$ (p.436 相等的传递性)。至此整个归纳过程结束。<span style="float: right">□</span>

2.2.3 证明命题 2.2.12（提示：你将用到前面的许多命题、推论和引理）

- （a）（序是自反的）$a \geqslant a$。
  - **证明：** 根据引理 2.2.2 $a+0=a$，再根据自然数序的定义（定义 2.2.11）可得 $a \geqslant a$。<span style="float: right">□</span>
- （b）（序是可传递的）如果 $a \geqslant b$ 并且 $b \geqslant c$，那么 $a \geqslant c$。
  - **证明：** 根据自然数序的定义（定义 2.2.11）如果 $a \geqslant b$，则必然存在自然数 $e$ 使得 $a=b+e$。类似地，如果 $b \geqslant c$，则必然存在自然数 $f$ 使得 $b=c+f$。于是我们有 $a=(c+f)+e$，根据加法的结合律（命题 2.2.5）可得 $a=c+(f+e)$，再根据定义 2.2.11 可得 $a \geqslant c$。<span style="float: right">□</span>
- （c）（序是反对称的）如果 $a \geqslant b$ 并且 $b \geqslant a$，那么 $a=b$。
  - **证明：** 根据定义 2.2.11 如果 $a \geqslant b$，则存在自然数 $c$ 使得 $a = b + c$。类似地，如果 $b \geqslant a$，则存在自然数 $d$ 使得 $b = a + d$，因此，$a = b+c = (a+d) + c$。根据引理 2.2.2，有 $a = a+0$，根据加法的结合律，有 $(a+d)+c=a+(d+c)$，于是 $a+0=a+(d+c)$，再根据加法的消去律可知 $d+c=0$。根据命题 2.2.9 可知 $d=$ 且 $c=0$，再根据引理 2.2.2 可得 $a = b + 0 = b$。<span style="float: right">□</span>
- （d）（加法保持序不变）$a \geqslant b$，当且仅当 $a+c \geqslant b +c$。
  - **证明：** 首先证明充分性，根据定义 2.2.11 $a \geqslant b$ 可以推出存在自然数 $d$ 使得 $a = b+d$，因此 $a + c = (b + d) + c$。根据加法的交换律和结合律可知 $a + c = (b + c) + c$。根据定义 2.2.11 可知，$a + c \geqslant b + c$。其次证明必要性，根据定义 2.2.11，$a + c \geqslant b + c$，则存在 自然数 $d$ 使得 $a+c = (b+c) + d$，根据加法的交换律和结合律可知 $a + c = (b + d) + c$，根据加法的消去律可知 $a = b + d$，再根据定义 2.2.11 可知 $a \geqslant  b$。<span style="float: right">□</span>
- （e）$a < b$，当且仅当 $a ++ \leqslant b$。
  - **证明：** 

[^1]: 严格来说，这个非正式的定义存在另外一个问题：我们尚未定义“集合”以及“元素”的概念。因此，在本章剩余的部分中，除了有关非正式的讨论内容，我们将尽量避免涉及集合以及集合中的元素。
[^2]: 这是一个用**逆否命题**来重新阐述原命题涵义的例子，更多的细节见 A.2 节。从命题的逆向来考虑，如果$n=m$，那么 $n++ = m++$；这就是被应用到 $++$ 运算上的**替换公理**（见 A.7 节）。
[^3]: 严格地说，该命题需要定义**函数**的概念。在下一章中，我们将给出函数的定义。然而这并非循环论证，原因在于定义函数的概念不需要用到皮亚诺公理。命题 2.1.16 可以用集合论的语言来描述得更加严格；参见习题 3.5.12。
[^4]: 从逻辑学的角度来说，引理、命题、定理和推论之间并没有什么不同——它们都是有待验证的一些论述。然而，我们使用这些术语是为了说明不同论述在重要性和困难程度上的不同。引理很容易被证明，它有助于进一步去证明其他的命题和定理，但是单独一个引理通常不会特别引起人们的关注。单独一个命题是值得研究的，而定理比命题更重要。定理是对研究对象权威性的描述，而且证明一个定理需要比证明一个命题或者引理付出更多的能力。推论是能够从目前已经被证明的命题或者定理中立即推导出的结论。